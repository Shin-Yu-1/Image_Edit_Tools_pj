<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>흑백 그림판</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js" integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf" crossorigin="anonymous"></script>

    <script>
        // 전역 변수(*중요*)
        var outCanvas, outCtx, inFile;  // 캔버스 관련
        var outPaper; // 캔버스에는 한점한점이 안찍힘. 대신 캔버스에 종이를 붙임.

        var inImageArray, outImageArray;  // 입력 파일 및 배열
        var inWidth, inHeight, outWidth, outHeight;  // 입력 영상의 폭과 높이

        function init() {// 공통 함수 
        outCanvas = document.getElementById('outCanvas');
        outCtx = outCanvas.getContext('2d');
        }


        function clear2(){ //전체 지우기
            const outCanvas = document.getElementById('outCanvas');
            const ctx = outCanvas.getContext('2d');
            ctx.clearRect(0, 0, outCanvas.width, outCanvas.height);
        }

        function openImage() { //이미지 배열 삽입
            inFile = document.getElementById('selectFile').files[0];
            // 중요! 코드 (영상의 크기를 파악)
            inWidth = inHeight = Math.sqrt(inFile.size);
            // 입력 2차원 배열을 준비
            inImageArray = new Array(inHeight); // 512짜리 1차원 배열
            for(var i=0; i<inHeight; i++) 
                inImageArray[i] = new Array(inWidth);
            // RAW 파일  --> 2차원 배열
            var reader = new FileReader();
            reader.readAsBinaryString(inFile);
            reader.onload = function () {
                var bin = reader.result; // 파일을 덩어리(bin)로 읽었음
                // 덩어리(bin)에서 한점한점씩 뽑아서, 배열에 넣기
                for(var i=0; i<inHeight; i++) {
                    for(var k=0; k<inWidth; k++) {
                        var sPixel = (i * inHeight + k);
                        var ePixel = (i * inHeight + k) + 1;
                        inImageArray[i][k] = bin.slice(sPixel,ePixel); // 1개픽셀-->배열
                    }
                }
                equalImage();
            }
        }
        function displayImage() {// 캔버스 크기를 결정
            outCanvas.width = outWidth;
            outCanvas.height = outHeight;
            outPaper = outCtx.createImageData(outHeight, outWidth); //종이 붙였음.
            for(var i=0; i<outHeight; i++) {
                for (var k=0; k<outWidth; k++) {
                    var charValue = outImageArray[i][k].charCodeAt(0); // 깨진문자를 숫자로.
                    outPaper.data[(i*outWidth + k) * 4 + 0] = charValue; // R
                    outPaper.data[(i*outWidth + k) * 4 + 1] = charValue; // G
                    outPaper.data[(i*outWidth + k) * 4 + 2] = charValue; // B
                    outPaper.data[(i*outWidth + k) * 4 + 3] = 255; // Alpha
                }
            }
            outCtx.putImageData(outPaper,0,0);
        }

        // *** 영상처리 함수 모음 ***
        function equalImage() {  // 동일 영상 알고리즘
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);
            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    outImageArray[i][k] = inImageArray[i][k];
                }
            }
            displayImage();
        }
        function addImage() {  // 영상 밝기 알고리즘
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            var value = parseInt(document.getElementById("brightI").value);
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    // 문자 --> 숫자
                    pixel = inImageArray[i][k].charCodeAt(0);
                    // **** 요기가 핵심 알고리즘. (밝게하기)
                    if (pixel + value > 255){
                        pixel = 255;
                    }
                    else if (pixel + value < 0) {
                        pixel = 0;
                    }
                    else{
                        pixel += value;
                    }
                    // 숫자 --> 문자
                    outImageArray[i][k] = String.fromCharCode(pixel);
                }
            }
            displayImage();
        }
        function bwImage() { // 흑백영상 알고리즘
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            var value = parseInt(document.getElementById("blackWhite").value);
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    // 문자 --> 숫자
                    pixel = inImageArray[i][k].charCodeAt(0);
                    // **** 요기가 핵심 알고리즘. (흑백)
                    if (pixel > value)
                        pixel = 255;
                    else   
                        pixel = 0;
                    // 숫자 --> 문자
                    outImageArray[i][k] = String.fromCharCode(pixel);
                }
            }
            displayImage();
        }
        function bwImageAvg() { //흑백영상(평균) 알고리즘
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            var hap = 0;
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) 
                    hap += inImageArray[i][k].charCodeAt(0);
            var value = hap / (inHeight*inWidth) ;

            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    // 문자 --> 숫자
                    pixel = inImageArray[i][k].charCodeAt(0);
                    // **** 요기가 핵심 알고리즘. (흑백)
                    if (pixel > value)
                        pixel = 255;
                    else   
                        pixel = 0;
                    // 숫자 --> 문자
                    outImageArray[i][k] = String.fromCharCode(pixel);
                }
            }
            displayImage();
        }
        function posterizingImage()/*포스터라이징*/ {
            //(중요!)출력 영상의 크기를 결정 ... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
           // 출력 2차원 배열 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);
            // **** 요기가 핵심 알고리즘.
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    pixel = inImageArray[i][k].charCodeAt(0);
                    if (pixel >= 231) {
                        pixel = 255;
                    } else if (pixel >= 206){
                        pixel = 230;
                    } else if (pixel >= 181){
                        pixel = 205;
                    } else if (pixel >= 156){
                        pixel = 180;
                    } else if (pixel >= 131){
                        pixel = 155;
                    } else if (pixel >= 106){
                        pixel = 130;
                    } else if (pixel >= 81){
                        pixel = 105;
                    } else if (pixel >= 56){
                        pixel = 80;
                    } else if (pixel >= 31){
                        pixel = 55;
                    }else pixel = 0;


                    // 숫자 --> 문자
                    outImageArray[i][k] = String.fromCharCode(pixel);
                }
            }
            displayImage();
        }
        function zoomOutImage() { //축소 알고리즘
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            var scale = parseInt(prompt("축소 배율(짝수)", "2"));
            outHeight = parseInt(inHeight/scale);
            outWidth = parseInt(inWidth/scale);
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    // **** 요기가 핵심 알고리즘. (영상 축소)
                    outImageArray[parseInt(i/scale)][parseInt(k/scale)] = inImageArray[i][k];
                }
            }
            displayImage();
        }
        function zoomInImage() { //확대 알고리즘
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            var scale = parseInt(prompt("확대 배율(짝수)", "2"));
            outHeight = inHeight*scale;
            outWidth = inWidth*scale;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);
            // outImageArray를 초기화 시키기 (0으로 채우기)
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) 
                    outImageArray[i][k] = String.fromCharCode(0);

            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<outHeight; i++) {
                for (var k=0; k<outWidth; k++) {
                    // **** 요기가 핵심 알고리즘. (영상 확대)
                    outImageArray[i][k] = inImageArray[parseInt(i/scale)][parseInt(k/scale)];
                }
            }
            displayImage();
        }
        function lrImage()/*좌우반전*/ {
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    // ** 요기가 핵심 알고리즘.
                    outImageArray[i][k] = inImageArray[i][inWidth-1-k];

                }
            }
            displayImage();
        }
        function udImage()/*상하반전*/ {
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    // ** 요기가 핵심 알고리즘.
                    outImageArray[i][k] = inImageArray[inHeight-1-i][k];

                }
            }
            displayImage();
        }
        function rotaImage() { //오른쪽 90도 회전
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight);
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);
            
            // ***** 진짜 영상처리 알고리즘 *****  
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    // ** 요기가 핵심 알고리즘.
                    outImageArray[i][k] = inImageArray[inWidth-1-i][k];
                }
            }

            for(var i=0; i<outWidth; i++) {
                for (var k=i; k<outHeight; k++) {
                    // ** 요기가 핵심 알고리즘.
                    tmp = outImageArray[i][k];
                    outImageArray[i][k] = outImageArray[k][i];
                    outImageArray[k][i] = tmp;

                    
                }
            }

            displayImage();
        }
        function rota1Image() { //회전 기본
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);
            
            // 출력 배열 초기화 >> outImageArray를 초기화 시키기 (0으로 채우기)
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) 
                    outImageArray[i][k] = String.fromCharCode(0);


            // ***** 진짜 영상처리 알고리즘 *****
            var degree = parseFloat(prompt("회전각도", 45));
            var radian = degree * Math.PI / 180.0;  // degree → radian으로 계산
            
            
            // xd = cos * xs - sin * ys;
            // yd = sin * xs + cos * ys;
            var xd, yd, xs, ys;
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    xs = i;
                    ys = k;
                    xd = parseInt(Math.cos(radian) * xs - Math.sin(radian) * ys);
                    yd = parseInt(Math.sin(radian) * xs + Math.cos(radian) * ys);

                    // 회전 이후의 위치가 출력영상의 범위 안에 있니?
                    if ( (0<=xd && xd<outHeight ) && (0<=yd && yd<outWidth))
                        outImageArray[xd][yd] = inImageArray[xs][ys];
                }
            }
            displayImage();
        }
        function rota2Image() {  //회전(백워딩, 중앙) 알고리즘
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);
            // outImageArray를 초기화 시키기 (0으로 채우기)
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) 
                    outImageArray[i][k] = String.fromCharCode(0);


            // ***** 진짜 영상처리 알고리즘 *****
            var degree = parseFloat(prompt("회전각도", 45));
            var radian = degree * Math.PI / 180.0; // degree->radian
            radian = -radian;
            // xd = cos * xs - sin * ys;
            // yd = sin * xs + cos * ys;
            var xd, yd, xs, ys;
            //중앙값 구하기
            var cx = parseInt(inHeight / 2);
            var cy = parseInt(inWidth / 2);
            for(var i=0; i<outHeight; i++) {
                for (var k=0; k<outWidth; k++) {
                    xs = i;
                    ys = k;
                    xd = parseInt(Math.cos(radian) * (xs-cx) - Math.sin(radian) * (ys-cy) + cx) ;
                    yd = parseInt(Math.sin(radian) * (xs-cx) + Math.cos(radian) * (ys-cy) + cy) ;

                    // 회전 이후의 위치가 출력영상의 범위 안에 있니?
                    if ( (0<=xd && xd<outHeight ) && (0<=yd && yd<outWidth))
                        outImageArray[xs][ys] = inImageArray[xd][yd];
                    else 
                        outImageArray[xs][ys] = String.fromCharCode(255);
                }
            }
            displayImage();
        }
        // function rota3Image() {  // 확대회전 알고리즘
        //     // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
        //     outHeight = inHeight;
        //     outWidth = inWidth;
        //     // 출력 2차원 배열을 준비
        //     outImageArray = new Array(outHeight); // 256짜리 1차원 배열
        //     for(var i=0; i<outHeight; i++) 
        //         outImageArray[i] = new Array(outWidth);
        //     // outImageArray를 초기화 시키기 (0으로 채우기)
        //     for(var i=0; i<outHeight; i++) 
        //         for (var k=0; k<outWidth; k++) 
        //             outImageArray[i][k] = String.fromCharCode(0);


        //     // ***** 진짜 영상처리 알고리즘 *****
        //     var degree = parseFloat(prompt("회전각도", 45));
        //     var radian = degree * Math.PI / 180.0; // degree->radian
        //     radian = -radian;
        //     // xd = cos * xs - sin * ys;
        //     // yd = sin * xs + cos * ys;
        //     var xd, yd, xs, ys;
        //     //중앙값 구하기
        //     var cx = parseInt(inHeight / 2);
        //     var cy = parseInt(inWidth / 2);
        //     for(var i=0; i<outHeight; i++) {
        //         for (var k=0; k<outWidth; k++) {
        //             xs = i;
        //             ys = k;
        //             xd = parseInt(Math.cos(radian) * (xs-cx) - Math.sin(radian) * (ys-cy) + cx) ;
        //             yd = parseInt(Math.sin(radian) * (xs-cx) + Math.cos(radian) * (ys-cy) + cy) ;

        //             // 회전 이후의 위치가 출력영상의 범위 안에 있니?
        //             if ( (0<=xd && xd<outHeight ) && (0<=yd && yd<outWidth))
        //                 outImageArray[xs][ys] = inImageArray[xd][yd];
        //             else 
        //                 outImageArray[xs][ys] = String.fromCharCode(255);
        //         }
        //     }
        //     displayImage();
        // }
        function histoStretch() { // 히스토그램 스트래칭
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            //  out =  ( in - low ) / ( high - low ) * 255
            var low = inImageArray[0][0].charCodeAt(0);
            var high = inImageArray[0][0].charCodeAt(0);
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    pixel = inImageArray[i][k].charCodeAt(0);
                    if (pixel < low) 
                        low = pixel;
                    if (pixel > high)
                        high = pixel
                }
            }
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    // 문자 --> 숫자
                    inVal = inImageArray[i][k].charCodeAt(0);
                    // **** 요기가 핵심 알고리즘.
                    outVal = ( inVal - low ) / ( high - low ) * 255;
                    // 숫자 --> 문자
                    outImageArray[i][k] = String.fromCharCode(outVal);
                }
            }
            displayImage();
        }
        function endInSearch() { //엔드-인 탐색
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            //  out =  ( in - low ) / ( high - low ) * 255
            var low = inImageArray[0][0].charCodeAt(0);
            var high = inImageArray[0][0].charCodeAt(0);
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    pixel = inImageArray[i][k].charCodeAt(0);
                    if (pixel < low) 
                        low = pixel;
                    if (pixel > high)
                        high = pixel
                }
            }
            low += 50;
            high -= 50;

            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    // 문자 --> 숫자
                    inVal = inImageArray[i][k].charCodeAt(0);
                    // **** 요기가 핵심 알고리즘. (흑백)
                    outVal = ( inVal - low ) / ( high - low ) * 255;
                    if (outVal > 255)
                        outVal = 255;
                    else if (outVal < 0)
                        outVal = 0;

                    // 숫자 --> 문자
                    outImageArray[i][k] = String.fromCharCode(outVal);
                }
            }
            displayImage();
        }
        function histoEqual() { //히스토그램 평활화
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            // 1단계 : 히스토그램 생성
            histo = new Array(256);  
            for (var i=0; i<256; i++)
                histo[i] = 0;
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    value = inImageArray[i][k].charCodeAt(0);
                    histo[value] ++;
                }
            // 2단계 : 누적 히스토그램 생성
            sumHisto = new Array(256);  
            for (var i=0; i<256; i++)
                sumHisto[i] = 0;     
            sumVal = 0;                       
            for (var i=0; i<256; i++) {
                sumVal += histo[i];
                sumHisto[i] = sumVal;
            }
            // 3단계 : 정규화된 누적히스토그램
            // ns = s * (1/픽셀총수) * 화소최대밝기
            normalHisto = new Array(256);  
            for (var i=0; i<256; i++)
                normalHisto[i] = 0.0; 
            for (var i=0; i<256; i++)
                normalHisto[i] = sumHisto[i] * ( 1 / (inWidth*inHeight)) * 255;
                
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    // 문자 --> 숫자
                    inVal = inImageArray[i][k].charCodeAt(0);
                    // **** 요기가 핵심 알고리즘. (흑백)
                    outVal = normalHisto[inVal];
                    if (outVal > 255)
                        outVal = 255;
                    else if (outVal < 0)
                        outVal = 0;
                    else 
                        outVal = parseInt(outVal);
                    // 숫자 --> 문자
                    outImageArray[i][k] = String.fromCharCode(outVal);
                }
            }
            displayImage();
        }
        function graphImage() { // 그래프
            var histo = new Array(256);
            for(var i=0; i<256; i++)
                histo[i] = 0;
            for(var i=0; i<outHeight; i++) {
                for(var k=0; k<outWidth; k++) {
                    // 문자 --> 숫자
                    value = inImageArray[i][k].charCodeAt(0);
                    // **** 요기가 핵심 알고리즘.
                    histo[value]++;
                }
            }
            var max = 0;
            var min = outHeight*outWidth;

            for(var i=0; i<256; i++) {
                if(histo[i] < min)
                    min = histo[i];
                if(histo[i] > max)
                    max = histo[i];
            }
            var dif = max - min
            var normalHisto = new Array(256);
            for(var i=0; i<256; i++) {
                normalHisto[i] = (histo[i] - min)*255/dif;
            }
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight);
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            for(var i=0; i<outHeight; i++) {
                for(var k=0; k<outWidth; k++) {
                    outImageArray[i][k] = 255;
                }
            }
            for(var i=0; i<outHeight; i++) {
                for(var k=0; k<normalHisto[i]; k++) {
                    outImageArray[outHeight-1-k][i] = 0;
                }
            }
            for(var i=0; i<outHeight; i++) {
                for (var k=0; k<outWidth; k++) {
                    // 숫자 --> 문자
                    outImageArray[i][k] = String.fromCharCode(outImageArray[i][k]);
                }
            }
            displayImage();
        }
        function embossImage() {  // 엠보싱 알고리즘
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            //// 화소 영역 처리
            var mask = [    [ -1., 0., 0.], 
                            [  0., 0., 0.], 
                            [  0., 0., 1.]    ]
            // 임시 입력 배열
            tempInputArray = new Array(inHeight+2); // 2칸 큼
            for(var i=0; i<inHeight + 2; i++) 
                tempInputArray[i] = new Array(inWidth + 2);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+2; i++) 
                for (var k=0; k<inWidth+2; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight);  // 덮어 씌울거라 굳이 초기화 안 해도 됨.
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);
            //회선연산하기
            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    var S = 0.0; //실수여야 함.
                    for (var m=0; m<3; m++) { //m,n이 마스크 배열의 행렬
                        for (var n=0; n<3; n++) {//배열 각각을 곱한 후 더하게 됨. 9번 도는 코드
                            S += mask[m][n] * tempInputArray[i+m][k+n].charCodeAt(0);
                        }
                    }
                    tempOutputArray[i][k] = S;
                }
            }
            // 만약, 마스크의 합계가 0이면, 결과를 127 더하자.
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) 
                    tempOutputArray[i][k] += 127.0;

            // 임시 출력 --> 진짜 출력 배열
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
            displayImage();
        }
        function blurrImage() {  // 블러링 알고리즘
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            //// 화소 영역 처리
            var mask = [    [ 1/9., 1/9., 1/9.], 
                            [ 1/9., 1/9., 1/9.], 
                            [ 1/9., 1/9., 1/9.]    ]
            // 임시 입력 배열
            tempInputArray = new Array(inHeight+2); // 2칸 큼
            for(var i=0; i<inHeight + 2; i++) 
                tempInputArray[i] = new Array(inWidth + 2);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+2; i++) 
                for (var k=0; k<inWidth+2; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight); // 덮어 씌울거라 굳이 초기화 안 해도 됨.
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);
            //회선연산하기
            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    var S = 0.0;
                    for (var m=0; m<3; m++) {
                        for (var n=0; n<3; n++) {
                            S += mask[m][n] * tempInputArray[i+m][k+n].charCodeAt(0);
                        }
                    }
                    tempOutputArray[i][k] = S;
                }
            }

            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
            displayImage();
        }
        function edgeImage() {  // 엣지 알고리즘
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            //// 화소 영역 처리
            var mask = [    [ 0., 0., 0.], 
                            [ -1., 1., 0.], 
                            [  0., 0., 0.]    ]
            // 임시 입력 배열
            tempInputArray = new Array(inHeight+2); // 2칸 큼
            for(var i=0; i<inHeight + 2; i++) 
                tempInputArray[i] = new Array(inWidth + 2);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+2; i++) 
                for (var k=0; k<inWidth+2; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight);  // 덮어 씌울거라 굳이 초기화 안 해도 됨.
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);
            //회선연산하기
            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    var S = 0.0; //실수여야 함.
                    for (var m=0; m<3; m++) { //m,n이 마스크 배열의 행렬
                        for (var n=0; n<3; n++) {//배열 각각을 곱한 후 더하게 됨. 9번 도는 코드
                            S += mask[m][n] * tempInputArray[i+m][k+n].charCodeAt(0);
                        }
                    }
                    tempOutputArray[i][k] = S;
                }
            }
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
            displayImage();
        }
        function laplacianImage() {  //라플라시안 알고리즘
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            //// 화소 영역 처리
            var mask = [    [ 1., 1., 1.], 
                            [ 1., -8., 1.], 
                            [  1., 1., 1.]    ]
            // 임시 입력 배열
            tempInputArray = new Array(inHeight+2); // 2칸 큼
            for(var i=0; i<inHeight + 2; i++) 
                tempInputArray[i] = new Array(inWidth + 2);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+2; i++) 
                for (var k=0; k<inWidth+2; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight);  // 덮어 씌울거라 굳이 초기화 안 해도 됨.
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);
            //회선연산하기
            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    var S = 0.0; //실수여야 함.
                    for (var m=0; m<3; m++) { //m,n이 마스크 배열의 행렬
                        for (var n=0; n<3; n++) {//배열 각각을 곱한 후 더하게 됨. 9번 도는 코드
                            S += mask[m][n] * tempInputArray[i+m][k+n].charCodeAt(0);
                        }
                    }
                    tempOutputArray[i][k] = S;
                }
            }
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
            displayImage();
        }
        function sharpeningImage() {  //샤프닝 알고리즘
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            //// 화소 영역 처리
            var mask = [    [ 0., -1., 0.], 
                            [ -1., 5., -1.], 
                            [ 0., -1., 0.]    ]
            // 임시 입력 배열
            tempInputArray = new Array(inHeight+2); // 2칸 큼
            for(var i=0; i<inHeight + 2; i++) 
                tempInputArray[i] = new Array(inWidth + 2);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+2; i++) 
                for (var k=0; k<inWidth+2; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight);  // 덮어 씌울거라 굳이 초기화 안 해도 됨.
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);
            //회선연산하기
            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    var S = 0.0; //실수여야 함.
                    for (var m=0; m<3; m++) { //m,n이 마스크 배열의 행렬
                        for (var n=0; n<3; n++) {//배열 각각을 곱한 후 더하게 됨. 9번 도는 코드
                            S += mask[m][n] * tempInputArray[i+m][k+n].charCodeAt(0);
                        }
                    }
                    tempOutputArray[i][k] = S;
                }
            }
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
            displayImage();
        }
        function gaussianImage() {  //가우시안 알고리즘
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            //// 화소 영역 처리
            var mask = [    [ 1/16., 1/8., 1/16.], 
                            [ 1/8., 1/4., 1/8.], 
                            [ 1/16., 1/8., 1/6.]    ]
            // 임시 입력 배열
            tempInputArray = new Array(inHeight+2); // 2칸 큼
            for(var i=0; i<inHeight + 2; i++) 
                tempInputArray[i] = new Array(inWidth + 2);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+2; i++) 
                for (var k=0; k<inWidth+2; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight);  // 덮어 씌울거라 굳이 초기화 안 해도 됨.
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);
            //회선연산하기
            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    var S = 0.0; //실수여야 함.
                    for (var m=0; m<3; m++) { //m,n이 마스크 배열의 행렬
                        for (var n=0; n<3; n++) {//배열 각각을 곱한 후 더하게 됨. 9번 도는 코드
                            S += mask[m][n] * tempInputArray[i+m][k+n].charCodeAt(0);
                        }
                    }
                    tempOutputArray[i][k] = S;
                }
            }
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
            displayImage();
        }
        function hpfSharpImage() {  //고주파샤프닝 알고리즘
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            //// 화소 영역 처리
            var mask = [    [ -1/9., -1/9., -1/9.], 
                            [ -1/9., 8/9., -1/9.], 
                            [ -1/9., -1/9., -1/9.]    ]
            // 임시 입력 배열
            tempInputArray = new Array(inHeight+2); // 2칸 큼
            for(var i=0; i<inHeight + 2; i++) 
                tempInputArray[i] = new Array(inWidth + 2);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+2; i++) 
                for (var k=0; k<inWidth+2; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight);  // 덮어 씌울거라 굳이 초기화 안 해도 됨.
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);
            //회선연산하기
            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    var S = 0.0; //실수여야 함.
                    for (var m=0; m<3; m++) { //m,n이 마스크 배열의 행렬
                        for (var n=0; n<3; n++) {//배열 각각을 곱한 후 더하게 됨. 9번 도는 코드
                            S += mask[m][n] * tempInputArray[i+m][k+n].charCodeAt(0);
                        }
                    }
                    tempOutputArray[i][k] = S;
                }
            }
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
            displayImage();
        }
        function loGImage() { //LoG연산자
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            //// 화소 영역 처리
            var mask = [    [ 0., 0., -1., 0., 0.], 
                            [ 0., -1, -2., -1., 0.], 
                            [ -1., -2., 16., -2., -1.], 
                            [ 0., -1., -2., -1., 0.], 
                            [ 0., 0., -1., 0., 0.]    ]
            // 임시 입력 배열
            tempInputArray = new Array(inHeight+4); // 4칸 큼
            for(var i=0; i<inHeight + 4; i++) 
                tempInputArray[i] = new Array(inWidth + 4);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+4; i++) 
                for (var k=0; k<inWidth+4; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight);  // 덮어 씌울거라 굳이 초기화 안 해도 됨.
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);
            //회선연산하기
            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    var S = 0.0; //실수여야 함.
                    for (var m=0; m<5; m++) { //m,n이 마스크 배열의 행렬
                        for (var n=0; n<5; n++) {//배열 각각을 곱한 후 더하게 됨. 9번 도는 코드
                            S += mask[m][n] * tempInputArray[i+m][k+n].charCodeAt(0);
                        }
                    }
                    tempOutputArray[i][k] = S;
                }
            }
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
            displayImage();
        }
        function doGImage() { //DoG연산자
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            //// 화소 영역 처리
            var mask = [    [ 0., 0., 0., -1., -1., -1., 0., 0., 0.], 
                            [ 0., -2., -3., -3., -3., -3., -3., -2., 0.], 
                            [ 0., -3., -2., -1., -1., -1., -2., -3., 0.], 
                            [ -1., -3., -1., 9., 9., 9., -1., -3., -1.], 
                            [ -1., -3., -1., 9., 19., 9., -1., -3., -1.], 
                            [ -1., -3., -1., 9., 9., 9., -1., -3., -1.], 
                            [ 0., -3., -2., -1., -1., -1., -2., -3., 0.], 
                            [ 0., -2., -3., -3., -3., -3., -3., -2., 0.], 
                            [ 0., 0., 0., -1., -1., -1., 0., 0., 0.]    ]
            // 임시 입력 배열
            tempInputArray = new Array(inHeight+8); // 4칸 큼
            for(var i=0; i<inHeight + 8; i++) 
                tempInputArray[i] = new Array(inWidth + 8);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+8; i++) 
                for (var k=0; k<inWidth+8; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight);  // 덮어 씌울거라 굳이 초기화 안 해도 됨.
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);
            //회선연산하기
            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    var S = 0.0; //실수여야 함.
                    for (var m=0; m<9; m++) { //m,n이 마스크 배열의 행렬
                        for (var n=0; n<9; n++) {//배열 각각을 곱한 후 더하게 됨. 9번 도는 코드
                            S += mask[m][n] * tempInputArray[i+m][k+n].charCodeAt(0);
                        }
                    }
                    tempOutputArray[i][k] = S;
                }
            }
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
            displayImage();
        }
        function onHomogenImage() {  // 유사 연산자 알고리즘
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            // 임시 입력 배열
            tempInputArray = new Array(inHeight+2); // 2칸 큼
            for(var i=0; i<inHeight + 2; i++) 
                tempInputArray[i] = new Array(inWidth+2);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+2; i++) 
                for (var k=0; k<inWidth+2; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight); // 덮어 씌울거라 굳이 초기화 안 해도 됨.
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);
            //회선연산하기
            // ***** 진짜 영상처리 알고리즘 *****
            var max;
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    max = 0.0;
                    for (var m=0; m<3; m++) {
                        for (var n=0; n<3; n++) {
                            if(Math.abs(tempInputArray[i+1][k+1].charCodeAt(0) - tempInputArray[i+m][k+n].charCodeAt(0)) >= max)
                            // 블록 가운데 값 - 블록의 주변 픽셀 값의 절대값 중에서 최대값을 찾음.
                                max = Math.abs(tempInputArray[i+1][k+1].charCodeAt(0) - tempInputArray[i+m][k+n].charCodeAt(0));
                        }
                    }
                    tempOutputArray[i][k] = max;
                }
            }
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
            displayImage();
        }
        function chaImage() {  // 차 연산자 알고리즘
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            // 임시 입력 배열
            tempInputArray = new Array(inHeight+2); // 2칸 큼
            for(var i=0; i<inHeight + 2; i++) 
                tempInputArray[i] = new Array(inWidth+2);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+2; i++) 
                for (var k=0; k<inWidth+2; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight); // 덮어 씌울거라 굳이 초기화 안 해도 됨.
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);
            //회선연산하기
            // ***** 진짜 영상처리 알고리즘 *****
            var max;
            for(var i=0; i<outHeight; i++) {
                for(var k=0; k<outWidth; k++) {
                    var max = 0.0;
                    pixel = Math.abs(tempInputArray[i+0][k+0].charCodeAt(0) - tempInputArray[i+2][k+2].charCodeAt(0));
                    if(pixel >= max)
                        max = pixel;
                    pixel = Math.abs(tempInputArray[i+0][k+1].charCodeAt(0) - tempInputArray[i+2][k+1].charCodeAt(0));
                    if(pixel >= max)
                        max = pixel;
                    pixel = Math.abs(tempInputArray[i+0][k+2].charCodeAt(0) - tempInputArray[i+2][k+0].charCodeAt(0));
                    if(pixel >= max)
                        max = pixel;
                    pixel = Math.abs(tempInputArray[i+1][k+2].charCodeAt(0) - tempInputArray[i+1][k+0].charCodeAt(0));
                    if(pixel >= max)
                        max = pixel;

                    tempOutputArray[i][k] = max;

                }
            }
            // 임시 출력 --> 진짜 출력 배열
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
            displayImage();
        }

        function saveImage() { //저장 함수
            console.log("saveImage()");
            var imageName = "Image";
            console.log(imageName.lenght);
            if (imageName.length == 0) {
                imageName = "image";
            }
            imageName += ".png";
            var savedImage = document.getElementById("saveImage");
            var image = document
                .getElementById("outCanvas")
                .toDataURL("image/png")
                .replace("image/png", "image/octet-stream");
            savedImage.setAttribute("download", imageName);
            savedImage.setAttribute("href", image);
        }

    </script>
</head>

<body onload="init()">

<style>
    html,body{height: 100%;
        background-image: url('coverImage.jpg');
        background-repeat: no-repeat;
        background-size: cover;
    }
    nav{
        margin-left: 1%;
    }
    span{
        margin-left: 1%;
    }
    .leftBox{
        margin-left: 1%;
        margin-right: 2%;
        width: 11%;
        float: left;
    }
    .canvas{
        height: 50%;
        width: 50%;
        margin-left: -256px;
        margin-right: 0%;
        margin-top: -256px;
        
    }
    .rightBox{
        width: 11%;
        float: right;

    }
    .tab{white-space: pre;}


</style>
<div>
</div>
        <nav class="navbar navbar-expand-lg navbar-light bg-light">
            <a class="navbar-brand" href="00홈페이지.html">   JK</a>
            <span class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarColor03" aria-controls="navbarColor03" aria-expanded="false" aria-label="Toggle navigation">
              <span class="navbar-toggler-icon"></span>
            </span>
          
            <div class="collapse navbar-collapse" id="navbarColor03">
              <ul class="navbar-nav mr-auto">
                <li class="nav-item active">
                  <a class="nav-link" href="00홈페이지.html">Home
                    <span class="sr-only">(Back)</span>
                  </a>
                <!-- </li>
                <li class="nav-item">
                  <a class="nav-link" href="#" onclick='equalImage()'>시작페이지</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="#" type='file' id='selectFile' onchange='openImage()'>Pricing</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="#">About</a>
                </li> -->

                  </div>
                </li>
              </ul>

            </div>
          </nav>
          <div class="btn-group btn-group-toggle" data-toggle="buttons"></div>
    <span>
        <input class="btn btn-outline-secondary" type='file' id='selectFile' onchange='openImage()'/></span>
        
</span><br><br>

<!-- btn btn-primary : 파랑 
    btn btn-success : 초록
    btn btn-warning : 노랑
    btn btn-info : 하늘색
    btn btn-danger : 빨강
    btn btn-default : 배경 없음(흰색?)

btn-outline-primary : 테두리 파란색
btn-outline-secondary : 테두리 회색
btn-outline-dark-->
<div class="leftBox">
    <div class="btn-group btn-group-toggle" data-toggle="buttons">
        <div class="btn-group-vertical">
                <span type="button" class="btn btn-outline-dark btn-sm" id='photo' onclick='equalImage()' style="font-size: small;">동일영상</span>
                <span type="button" class="btn btn-outline-dark btn-sm" id="chaedo" onclick="document.getElementById('brightI').style.display='block'">밝기</span>
                <input type="range" max="255" min="-255" value="0" class="btn btn-outline-secondary btn-sm" id="brightI" onclick="addImage()" style = 'display: none'>
                <span type="button" class="btn btn-outline-dark btn-sm" id="chaedo" onclick="document.getElementById('blackWhite').style.display='block'">흑백</span>
                <input type="range" max="255" min="0" value="127" class="btn btn-outline-secondary btn-sm" id='blackWhite' onclick="bwImage()" style = 'display: none'>
                <span type="button" class="btn btn-outline-dark btn-sm" id='photo' onclick='bwImageAvg()' style="font-size: small;">흑백(평균값)</span>
                <span type="button" class="btn btn-outline-dark btn-sm" id='photo' onclick='posterizingImage()' style="font-size: small;">포스터라이징</span>
                <span type="button" class="btn btn-outline-dark btn-sm" id='photo' onclick='zoomOutImage()' style="font-size: small;">축소</span>
                <span type="button" class="btn btn-outline-dark btn-sm" id='photo' onclick='zoomInImage()' style="font-size: small;">확대</span>
                <span type="button" class="btn btn-outline-dark btn-sm" id='photo' onclick='lrImage()' style="font-size: small;">좌우반전</span>
                <span type="button" class="btn btn-outline-dark btn-sm" id='photo' onclick='udImage()' style="font-size: small;">상하반전</span>
                <span type="button" class="btn btn-outline-dark btn-sm" id='photo' onclick='rotaImage()' style="font-size: small;">오른쪽 회전</span>
                <span type="button" class="btn btn-outline-dark btn-sm" id='photo' onclick='rota1Image()' style="font-size: small;">회전 기본</span>
                <span type="button" class="btn btn-outline-dark btn-sm" id='photo' onclick='rota2Image()' style="font-size: small;">회전 백워딩</span>
                <!-- <span type="button" class="btn btn-outline-dark btn-sm" id='photo' onclick='rota3Image()' style="font-size: small;">확대회전 백워딩</span> -->

    </div></div></div>

    <Canvas id="outCanvas" style="background: rgb(255, 255, 255);"></Canvas>

<div class="rightBox">
    <div class="btn-group-vertical" data-toggle="buttons">
        <div class="btn-group-vertical">
        <span type="button" class="btn btn-outline-secondary" id='free' onclick='histoStretch()' style="font-size: small;">히스토그램 스트래칭</span>
        <span type="button" class="btn btn-outline-secondary" id='free' onclick='endInSearch()' style="font-size: small;">엔드-인 탐색</span>
        <span type="button" class="btn btn-outline-secondary" id='free' onclick='histoEqual()' style="font-size: small;">히스토그램 평활화</span>
        <span type="button" class="btn btn-outline-secondary" id='free' onclick='graphImage()' style="font-size: small;">그래프</span>
        <span type="button" class="btn btn-outline-secondary" id='free' onclick='embossImage()' style="font-size: small;">엠보싱처리</span>
        <span type="button" class="btn btn-outline-secondary" id='free' onclick='blurrImage()' style="font-size: small;">블러처리</span>
        <span type="button" class="btn btn-outline-secondary" id='free' onclick='edgeImage()' style="font-size: small;">엣지검출</span>
        <span type="button" class="btn btn-outline-secondary" id='free' onclick='laplacianImage()' style="font-size: small;">라플라시안</span>
        <span type="button" class="btn btn-outline-secondary" id='free' onclick='gaussianImage()' style="font-size: small;">가우시안</span>
        <span type="button" class="btn btn-outline-secondary" id='free' onclick='sharpeningImage()' style="font-size: small;">샤프닝</span>
        <span type="button" class="btn btn-outline-secondary" id='free' onclick='hpfSharpImage()' style="font-size: small;">고주파 샤프닝</span>
        <span type="button" class="btn btn-outline-secondary" id='free' onclick='loGImage()' style="font-size: small;">LoG</span>
        <span type="button" class="btn btn-outline-secondary" id='free' onclick='doGImage()' style="font-size: small;">DoG</span>
        <span type="button" class="btn btn-outline-secondary" id='free' onclick='onHomogenImage()' style="font-size: small;">유사 연산자</span>
        <span type="button" class="btn btn-outline-secondary" id='free' onclick='chaImage()' style="font-size: small;">차 연산자</span>
        <a id="saveImage" download="image.png" type="button" class="btn btn-outline-secondary" value="Save" onClick="saveImage()">저장</a>
        </div></div>
</body>
</html>
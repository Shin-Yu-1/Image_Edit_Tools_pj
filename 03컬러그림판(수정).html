<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>컬러 그림판</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js" integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf" crossorigin="anonymous"></script>

</head>
<body>
    <style>
        
        html,body{height: 100%;
        background-image: url('coverImage.jpg');
        background-repeat: no-repeat;
        background-size: cover;
        }
        nav {
            margin-left: 1%;
        }
        div {
            margin-left: 1%;
            margin-bottom: 1%;
        }
        span {
            margin-left: 1%;
        }
        .rightBox {
            margin-right: 1%;
            width: 250px;
            float: right;
            font-size: x-small;
        }
        .canvas{
            margin-left: 25%;
            height: 50%;
            width: 50%;
            float: center;
        
    }
    </style>
        <nav class="navbar navbar-expand-lg navbar-light bg-light">
            <a class="navbar-brand" href="00홈페이지.html">   JK</a>
            <span class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarColor03" aria-controls="navbarColor03" aria-expanded="false" aria-label="Toggle navigation">
              <span class="navbar-toggler-icon"></span>
            </span>
          
            <div class="collapse navbar-collapse" id="navbarColor03">
              <ul class="navbar-nav mr-auto">
                <li class="nav-item active">
                  <a class="nav-link" href="00홈페이지.html">Home
                    <span class="sr-only">(Back)</span>
                  </a>
                <!-- </li>
                <li class="nav-item">
                  <a class="nav-link" href="#" onclick='equalImage()'>시작페이지</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="#" type='file' id='selectFile' onchange='openImage()'>Pricing</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="#">About</a>
                </li> -->
    
                  </div>
                </li>
              </ul>
            </div>
        </nav>
    
    <div class="selectBtn">
        <div class="options"> <!--옵션 버튼-->
            <b>그리기</b>
        <select id="type">  <!-- 선 / 사각형 / 지우개 -->
            <option value = 0> 도구 선택 </option>
            <option value="stroke">실선</option>
            <option value="square">사각형</option>
            <option value="eraser">지우개</option>
        </select>
        <select id="strokeStyle"> <!-- 선 색상 -->
            <option value = 0> 색상 선택 </option>
            <option style="color: #ffffff;background-color:pink;font-family:fantasy;" value="pink">분홍색</option>
            <option style="color: #ffffff;background-color:red" value="red">빨간색</option>
            <option style="color: #ffffff;background-color:orange" value="orange">주황색</option>
            <option style="color: #ffffff;background-color:yellow" value="yellow">노랑색</option>
            <option style="color: #ffffff;background-color:green" value="green">초록색</option>
            <option style="color: #ffffff;background-color:blue" value="blue">파란색</option>
            <option style="color: #ffffff;background-color:navy" value="navy">남색</option>
            <option style="color: #ffffff;background-color:purple" value="purple">보라색</option>
            <option style="color: #000000;background-color:white;font-family:fantasy;" value="white">흰색</option>
            <option style="color: #ffffff;background-color:black;font-family:fantasy;" value="black">검정색</option>
        </select>  
        <select id="lineWidth"> <!-- 선 굵기 -->
            <option value = 0> 굵기 선택 </option>
            <option value="5">5px</option>
            <option value="10">10px</option>
            <option value="15">15px</option>
            <option value="20">20px</option>
        </select></div></div>
    <div class="normalCenter">  <!-- 효과 버튼 -->
        
        <input type='file' id='selectFile' onchange='openImage()'/>
        
    </div>
    <div class="rightBox">
        <div class="btn-group btn-group-toggle" data-toggle="buttons">
            <div class="btn-group-vertical">
                <span type="button" class="btn btn-outline-secondary" id='selectFile' onclick ='clear2()'>전체 지우기</span>
                <span type="button" class="btn btn-outline-secondary" id='origin' onclick ='equalImage()'>원본</span>
                <span type="button" class="btn btn-outline-dark" id="chaedo" onclick="document.getElementById('brightI').style.display='block'">밝기</span>
                <input type="range" max="255" min="-255" value="0" class="btn btn-outline-secondary" id="brightI" onclick="addImage()" style = 'display: none'>
                <span type="button" class="btn btn-outline-secondary" id='grayS' onclick = 'grayScale()'>그레이스케일</span>
                <span type="button" class="btn btn-outline-dark" id="chaedo" onclick="document.getElementById('blackWhite').style.display='block'">흑백</span>
                <input type="range" max="255" min="0" value="127" class="btn btn-outline-secondary" id='blackWhite' onclick="bwImage()" style = 'display: none'>
                <input type="range" max="255" min="-255" value="0" class="btn btn-outline-dark" id='bwI' onclick = 'bwImage()' style = 'display: none'>
                <span type="button" class="btn btn-outline-secondary" id='photoBw' onclick = 'posterizingImage()'>포스터라이징</span>
                <span type="button" class="btn btn-outline-secondary" id='photoBw' onclick = 'reverseImage()'>반전</span>
                <span type="button" class="btn btn-outline-secondary" id="chaedo" onclick="document.getElementById('changeHSV').style.display='block'">채도</span>
                <input type="range" max="1" min="-1" value="0" step="0.1" class="btn btn-outline-dark" id='changeHSV' onclick = 'changeHsvImage()' style = 'display: none'>
                <span type="button" class="btn btn-outline-secondary" id='findR' onclick = 'findRed()'>붉은색 추출</span>
                <span type="button" class="btn btn-outline-secondary" id='photoBw' onclick = 'findBlue()'>파란색 추출</span>
                <span type="button" class="btn btn-outline-secondary" id='photoBw' onclick = 'findYellow()'>노란색 추출</span>
        <!-- <div class="button">저장 버튼 -->
                <a id="saveImage" download="image.png" type="button" class="btn btn-outline-secondary" value="Save" onClick="saveImage()">저장</a>
    </div></div></div>
    
    <div class="center">
        <Canvas id="outCanvas" ></Canvas>
    </div>
    <script>
        // 전역 변수(*중요*)
        var outCanvas, outCtx, inFile;  // 입력 캔버스 관련
        var inPaper, outPaper; // 캔버스에는 한점한점이 안찍힘. 대신 캔버스에 종이를 붙임.

        var inImageArray, outImageArray;  // 입력 파일 및 배열
        var inWidth, inHeight, outWidth, outHeight;  // 입력 영상의 폭과 높이

        // 공통 함수
        outCanvas = document.getElementById('outCanvas');
        outCtx = outCanvas.getContext('2d');
        function tDArr() { //3차원 배열 만들기
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 3차원 배열을 준비
            outImageArray = new Array(3); // 512짜리 1차원 배열
            for (var i=0; i<3; i++) {
                outImageArray[i] = new Array(outHeight); // 512짜리 1차원 배열
                for(var k=0; k<outHeight; k++) 
                    outImageArray[i][k] = new Array(outWidth);
        }
    }

        let isAbleDraw = false;
        const options = {
            type: 'stroke',
            strokeStyle: 'black',
            lineWidth: 5,
        };
        var rects = [];
        let currentRect = null;
        document.getElementById('outCanvas').addEventListener('mousedown', () => {
            isAbleDraw = true;
            currentRect = {
                type: options.type,
                strokeStyle: options.strokeStyle,
                lineWidth: options.lineWidth,
                coordinates: [],
            };
        });
        document.getElementById('outCanvas').addEventListener('mousemove', (e) => {
            if (isAbleDraw) {
                const outCtx = e.target.getContext('2d');
                const [x, y] = [e.offsetX, e.offsetY];
                currentRect.coordinates.push([x, y]);
                // 가이드선
                drawTools.execute(rects);
                if (currentRect.type === 'stroke') drawTools.stroke(currentRect.coordinates, 'rgba(255, 255, 0, .3)', currentRect.lineWidth);
                if (currentRect.type === 'eraser') drawTools.eraser(currentRect.coordinates, currentRect.lineWidth);
                if (currentRect.type === 'square') drawTools.square(currentRect.coordinates, 'rgba(255, 255, 0, .3)');
            }
        });
        document.getElementById('outCanvas').addEventListener('mouseup', () => {
            isAbleDraw = false;
            rects.push(currentRect);
            currentRect = null;
            drawTools.execute(rects);
            console.log(rects);
        })
        const drawTools = {
            clear() {// 캔버스 내용 제거
                const outCanvas = document.getElementById('outCanvas');
                ouCtx.clearRect(0, 0, outCanvas.outWidth, outCanvas.outHeight);
                const outCtx = outCanvas.getContext('2d');
            },
            stroke(coordinates, color, lineWidth) {
               // 마우스가 이동한 경로를 따라 실선 그리기
                if (coordinates.length > 0) {
                    const outCtx = document.getElementById('outCanvas').getContext('2d');
                    const firstCoordinate = coordinates[0];
                    outCtx.beginPath();
                    outCtx.moveTo(firstCoordinate[0], firstCoordinate[1]);
                    for (let i = 1; i < coordinates.length; i += 1) {
                        outCtx.lineTo(coordinates[i][0], coordinates[i][1]);
                    }
                    outCtx.strokeStyle = color;
                    outCtx.lineWidth = lineWidth;
                    outCtx.stroke();
                    outCtx.closePath();
                }
            },
            eraser(coordinates, lineWidth) {
               // 마우스가 이동한 좌표에 따라 하얀색으로 원을 그려서 지우개 기능처럼 동작
                const outCanvas = document.getElementById('outCanvas');
                const outCtx = outCanvas.getContext('2d');
                for (let i = 0; i < coordinates.length; i += 1) {
                    outCtx.beginPath();
                    const coordinate = coordinates[i];
                    const [x, y] = coordinate;
                    outCtx.fillStyle = 'white';
                    outCtx.arc(x, y, lineWidth / 2, 0, Math.PI * 2);
                    outCtx.fill();
                    outCtx.closePath();
                }
            },
            execute(rects) {
               // rects 배열에 저장 된 도형을 기준으로 다시 캔버스에 그림
                for (let i = 0; i < rects.length;  i += 1) {
                    const rect = rects[i];
                    const { type } = rect;
                    if (type === 'stroke') this.stroke(rect.coordinates, rect.strokeStyle, rect.lineWidth);
                    if (type === 'eraser') this.eraser(rect.coordinates, rect.lineWidth);
                    if (type === 'square') this.square(rect.coordinates, rect.strokeStyle);
                }
                for(let i =0;i<rects.length;i++){
                    rects[i] = String.fromCharCode(0);
                }
            },
            square(coordinates, color) {
               // 사각 도형을 그림
                const outCanvas = document.getElementById('outCanvas');
                const outCtx = outCanvas.getContext('2d');
                const start = coordinates[0];
                const end = coordinates[coordinates.length - 1];
                const [startX, startY] = start;
                const [endX, endY] = [end[0] - startX, end[1] - startY];
                outCtx.beginPath();
                outCtx.fillStyle = color;
                outCtx.fillRect(startX, startY, endX, endY);
                outCtx.closePath();
            },
        };
        document.getElementById('type').addEventListener('change', (e) => {
            options.type = e.target.value;
        });
        document.getElementById('strokeStyle').addEventListener('change', (e) => {
            options.strokeStyle = e.target.value;
        });
        document.getElementById('lineWidth').addEventListener('change', (e) => {
            options.lineWidth = e.target.value;
        });

        function openImage() { //이미지 파일을 배열에 넣는 함수
            inFile = document.getElementById('selectFile').files[0];
            //그림 파일 >> 이미지 객체로 불러오기
            var inImage = new Image(); //빈 이미지 객체 생성
            inImage.src = inFile.name;

            inImage.onload = function(){
                //입력 파일의 크기를 알아냄
                inWidth = inImage.width;
                inHeight = inImage.height;

                // 캔버스 크기를 결정
                outCanvas.width = inWidth;
                outCanvas.height = inHeight;
                outCtx.drawImage(inImage, 0, 0, inWidth, inHeight);

                // 입력 3차원 배열을 준비
                inImageArray = new Array(3); // 3장짜리 배열 (r, g, b)
                 for(var i=0; i<3; i++) {//1.총 3장만들기 위해서 3번 반복
                    inImageArray[i] = new Array(inHeight); //2. 1장마다 2차원 배열 생성
                    for(var k=0; k<inHeight; k++){
                        inImageArray[i][k]=new Array(inWidth);
                    }
                }

                //출력된 캔버스에서 픽셀값 뽑아내기
                var imageData = outCtx.getImageData(0,0, inWidth, inHeight);
                var pixel_image = imageData.data;
                var R, G, B;
                for(var i=0; i<inHeight; i++){
                    for(var k=0; k<inWidth; k++){
                        px = (i*inWidth + k) * 4; //1픽셀 = 4byte(r,g,b,alpha값까지 포함) //순서는 0,4,8~~
                        R = imageData.data[px+0];
                        G = imageData.data[px+1];
                        B = imageData.data[px+2];
                        // Alpha = imageData.data[px+3]; //알파값(투명도)까지 한다면 추가하기
                        
                        inImageArray[0][i][k] = String.fromCharCode(R);
                        inImageArray[1][i][k] = String.fromCharCode(G);
                        inImageArray[2][i][k] = String.fromCharCode(B);
                        
                    }
                }
            }
        }
       ///////  영상 처리 함수 모음 //////////
       function displayImage() {// 캔버스 크기를 결정
            outCanvas.height = outHeight;
            outCanvas.width = outWidth;

            var R, G, B;
            outPaper = outCtx.createImageData(outWidth, outHeight); // 종이에 붙였음
            for(var i=0; i<outHeight; i++) {
                for (var k=0; k<outWidth; k++) {
                    R = outImageArray[0][i][k].charCodeAt(0); // Byte 문자를 숫자로.
                    G = outImageArray[1][i][k].charCodeAt(0); // Byte 문자를 숫자로.
                    B = outImageArray[2][i][k].charCodeAt(0); // Byte 문자를 숫자로.
                    outPaper.data[(i*outWidth + k) * 4 + 0] = R;
                    outPaper.data[(i*outWidth + k) * 4 + 1] = G;
                    outPaper.data[(i*outWidth + k) * 4 + 2] = B;
                    outPaper.data[(i*outWidth + k) * 4 + 3] = 255;
                }
            }
            outCtx.putImageData(outPaper, 0, 0);
        }
        function equalImage() { //동일 영상 출력
            tDArr();
            // ***** 진짜 영상처리 알고리즘 *****
            for (var rgb=0; rgb<3; rgb++) {
                for(var i=0; i<inHeight; i++) {
                    for (var k=0; k<inWidth; k++) {
                        outImageArray[rgb][i][k] = inImageArray[rgb][i][k];
                    }
                }
            }
            displayImage();
        }
        function addImage() { // 영상 밝기 조절 알고리즘
            tDArr();
            // ***** 진짜 영상처리 알고리즘 *****
            var value = parseInt(document.getElementById("brightI").value);
            for (var rgb=0; rgb<3; rgb++) {
                for(var i=0; i<inHeight; i++) {
                    for (var k=0; k<inWidth; k++) {
                        // 문자 --> 숫자
                        pixel = inImageArray[rgb][i][k].charCodeAt(0);
                        // ** 핵심 알고리즘 **
                        if (pixel + value > 255)
                            pixel = 255;
                        else if (pixel + value < 0)
                            pixel = 0;
                        else    
                            pixel += value;
                        // 숫자 --> 문자
                        outImageArray[rgb][i][k] = String.fromCharCode(pixel);
                    }
                }
            }
            displayImage();
        }
        function grayScale() { //그레이스케일
            tDArr();
            // ***** 진짜 영상처리 알고리즘 *****
            var R, G, B;
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    R = inImageArray[0][i][k].charCodeAt(0);
                    G = inImageArray[1][i][k].charCodeAt(0);
                    B = inImageArray[2][i][k].charCodeAt(0);

                    var RGB = parseInt((R+G+B) / 3);

                    outImageArray[0][i][k] = String.fromCharCode(RGB);
                    outImageArray[1][i][k] = String.fromCharCode(RGB);
                    outImageArray[2][i][k] = String.fromCharCode(RGB);
                    }
                }
            displayImage();
            }
        function bwImage() { // 흑백영상 알고리즘
            tDArr();
            // ***** 진짜 영상처리 알고리즘 *****
            var value = parseInt(document.getElementById("blackWhite").value);
            var R, G, B;
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    // 문자 --> 숫자
                    R = inImageArray[0][i][k].charCodeAt(0);
                    G = inImageArray[1][i][k].charCodeAt(0);
                    B = inImageArray[2][i][k].charCodeAt(0);

                    var RGB = parseInt((R+G+B) / 3);
                    if (RGB > value)
                        RGB = 255;
                    else
                        RGB = 0;
                    // 숫자 --> 문자
                    outImageArray[0][i][k] = String.fromCharCode(RGB);
                    outImageArray[1][i][k] = String.fromCharCode(RGB);
                    outImageArray[2][i][k] = String.fromCharCode(RGB);
                    }
                }
            displayImage();
            }
        function posterizingImage()/*포스터라이징*/ {
            tDArr();
            // ***** 진짜 영상처리 알고리즘 *****
            var R, G, B;
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    // 문자 --> 숫자
                    R = inImageArray[0][i][k].charCodeAt(0);
                    if (R >= 231) {
                        R = 255;
                        } else if (R >= 206){
                            R = 230;
                        } else if (R >= 181){
                            R = 205;
                        } else if (R >= 156){
                            R = 180;
                        } else if (R >= 131){
                            R = 155;
                        } else if (R >= 106){
                            R = 130;
                        } else if (R >= 81){
                            R = 105;
                        } else if (R >= 56){
                            R = 80;
                        } else if (R >= 31){
                            R = 55;
                        }else R = 0;
                    G = inImageArray[1][i][k].charCodeAt(0);
                    if (G >= 231) {
                        G = 255;
                        } else if (G >= 206){
                            G = 230;
                        } else if (G >= 181){
                            G = 205;
                        } else if (G >= 156){
                            G = 180;
                        } else if (G >= 131){
                            G = 155;
                        } else if (G >= 106){
                            R = 130;
                        } else if (G >= 81){
                            G = 105;
                        } else if (G >= 56){
                            G = 80;
                        } else if (G >= 31){
                            G = 55;
                        }else G = 0;
                    B = inImageArray[2][i][k].charCodeAt(0);
                        if (B >= 231) {
                            B = 255;
                        } else if (B >= 206){
                            B = 230;
                        } else if (B >= 181){
                            B = 205;
                        } else if (B >= 156){
                            B = 180;
                        } else if (B >= 131){
                            B = 155;
                        } else if (B >= 106){
                            B = 130;
                        } else if (B >= 81){
                            B = 105;
                        } else if (B >= 56){
                            B = 80;
                        } else if (B >= 31){
                            B = 55;
                        }else B = 0;
                        // 숫자 --> 문자
                    outImageArray[0][i][k] = String.fromCharCode(R);
                    outImageArray[1][i][k] = String.fromCharCode(G);
                    outImageArray[2][i][k] = String.fromCharCode(B);
                }
            }
            displayImage();
        }
        function reverseImage() { //반전 알고리즘
            tDArr();
            // ***** 진짜 영상처리 알고리즘 *****
            var R, G, B;
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    // 문자 --> 숫자
                    R = inImageArray[0][i][k].charCodeAt(0);
                    R = 255-R;
                    G = inImageArray[1][i][k].charCodeAt(0);
                    G = 255-G;
                    B = inImageArray[2][i][k].charCodeAt(0);
                    B = 255-B;

                    // 숫자 --> 문자
                    outImageArray[0][i][k] = String.fromCharCode(R);
                    outImageArray[1][i][k] = String.fromCharCode(G);
                    outImageArray[2][i][k] = String.fromCharCode(B);
                    }
                }
            displayImage();
        }
        function changeHsvImage(){ //채도변경 알고리즘
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 3차원 배열을 준비
            outImageArray = new Array(3); // 512짜리 1차원 배열
            for (var i=0; i<3; i++) {
                outImageArray[i] = new Array(outHeight); // 512짜리 1차원 배열
                for(var k=0; k<outHeight; k++) 
                    outImageArray[i][k] = new Array(outWidth);
            }
            
            // ***** 진짜 영상처리 알고리즘 *****
            var value = parseFloat(document.getElementById("changeHSV").value);
            var R,G,B;
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    R = inImageArray[0][i][k].charCodeAt(0);
                    G = inImageArray[1][i][k].charCodeAt(0);
                    B = inImageArray[2][i][k].charCodeAt(0);

                    var hsv = rgb2hsv (R, G, B)
                    var H = hsv.h;
                    var S = hsv.s;
                    var V = hsv.v;
                    
                    S += value;

                    var rgb = hsv2rgb(H, S, V)
                    var R = rgb.r;
                    var G = rgb.g;
                    var B = rgb.b;

                    outImageArray[0][i][k] = String.fromCharCode(R);
                    outImageArray[1][i][k] = String.fromCharCode(G);
                    outImageArray[2][i][k] = String.fromCharCode(B);
                }
            }
            displayImage();

        }
        function findRed() { //붉은색 추출
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 3차원 배열을 준비
            outImageArray = new Array(3); // 512짜리 1차원 배열
            for (var i=0; i<3; i++) {
                outImageArray[i] = new Array(outHeight); // 512짜리 1차원 배열
                for(var k=0; k<outHeight; k++) 
                    outImageArray[i][k] = new Array(outWidth);
            }
            
            // ***** 진짜 영상처리 알고리즘 *****
            var R,G,B;
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    R = inImageArray[0][i][k].charCodeAt(0);
                    G = inImageArray[1][i][k].charCodeAt(0);
                    B = inImageArray[2][i][k].charCodeAt(0);

                    var hsv = rgb2hsv (R, G, B)
                    var H = hsv.h;
                    var S = hsv.s;
                    var V = hsv.v;
                    
                    if (( -15 < (H*360) && (H*360) < 15)) {  // 붉은색 / 검색 키워드 : hsv 색상 추출
                        S += 0.3;
                        var hsv = rgb2hsv (R, G, B)
                        var H = hsv.h;
                        var S = hsv.s;
                        var V = hsv.v;
                        outImageArray[0][i][k] = String.fromCharCode(R);
                        outImageArray[1][i][k] = String.fromCharCode(G);
                        outImageArray[2][i][k] = String.fromCharCode(B);
                    } else { // 나머지 색을 그레이 스케일로
                        var RGB = parseInt( (R + G + B) / 3 );
                        outImageArray[0][i][k] = String.fromCharCode(RGB);
                        outImageArray[1][i][k] = String.fromCharCode(RGB);
                        outImageArray[2][i][k] = String.fromCharCode(RGB);
                    }

                }
            }
            displayImage();
        }
        function findBlue() { //파란색 추출
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 3차원 배열을 준비
            outImageArray = new Array(3); // 512짜리 1차원 배열
            for (var i=0; i<3; i++) {
                outImageArray[i] = new Array(outHeight); // 512짜리 1차원 배열
                for(var k=0; k<outHeight; k++) 
                    outImageArray[i][k] = new Array(outWidth);
            }
            
            // ***** 진짜 영상처리 알고리즘 *****
            var R,G,B;
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    R = inImageArray[0][i][k].charCodeAt(0);
                    G = inImageArray[1][i][k].charCodeAt(0);
                    B = inImageArray[2][i][k].charCodeAt(0);

                    var hsv = rgb2hsv (R, G, B)
                    var H = hsv.h;
                    var S = hsv.s;
                    var V = hsv.v;
                    
                    if ( 200 < (H*360) && (H*360) < 240) {  // 붉은색 / 검색 키워드 : hsv 색상 추출
                        S += 0.3;
                        var hsv = rgb2hsv (R, G, B)
                        var H = hsv.h;
                        var S = hsv.s;
                        var V = hsv.v;
                        outImageArray[0][i][k] = String.fromCharCode(R);
                        outImageArray[1][i][k] = String.fromCharCode(G);
                        outImageArray[2][i][k] = String.fromCharCode(B);
                    } else { // 나머지 색을 그레이 스케일로
                        var RGB = parseInt( (R + G + B) / 3 );
                        outImageArray[0][i][k] = String.fromCharCode(RGB);
                        outImageArray[1][i][k] = String.fromCharCode(RGB);
                        outImageArray[2][i][k] = String.fromCharCode(RGB);
                    }

                }
            }
            displayImage();
        }
        function findYellow() { //노란색 추출
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 3차원 배열을 준비
            outImageArray = new Array(3); // 512짜리 1차원 배열
            for (var i=0; i<3; i++) {
                outImageArray[i] = new Array(outHeight); // 512짜리 1차원 배열
                for(var k=0; k<outHeight; k++) 
                    outImageArray[i][k] = new Array(outWidth);
            }
            
            // ***** 진짜 영상처리 알고리즘 *****
            var R,G,B;
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    R = inImageArray[0][i][k].charCodeAt(0);
                    G = inImageArray[1][i][k].charCodeAt(0);
                    B = inImageArray[2][i][k].charCodeAt(0);

                    var hsv = rgb2hsv (R, G, B)
                    var H = hsv.h;
                    var S = hsv.s;
                    var V = hsv.v;
                    
                    if ( 35 < (H*360) && (H*360) < 57) {  // 노란색 / 검색 키워드 : hsv 색상 추출
                        S += 0.3;
                        var hsv = rgb2hsv (R, G, B)
                        var H = hsv.h;
                        var S = hsv.s;
                        var V = hsv.v;
                        outImageArray[0][i][k] = String.fromCharCode(R);
                        outImageArray[1][i][k] = String.fromCharCode(G);
                        outImageArray[2][i][k] = String.fromCharCode(B);
                    } else { // 나머지 색을 그레이 스케일로
                        var RGB = parseInt( (R + G + B) / 3 );
                        outImageArray[0][i][k] = String.fromCharCode(RGB);
                        outImageArray[1][i][k] = String.fromCharCode(RGB);
                        outImageArray[2][i][k] = String.fromCharCode(RGB);
                    }

                }
            }
            displayImage();
        }
        //함수에서 리턴값은 하나밖에 못함
        function rgb2hsv(r, g, b) {
            var max = Math.max(r, g, b), min = Math.min(r, g, b),
                d = max - min,
                h,
                s = (max === 0 ? 0 : d / max),
                v = max / 255;

            switch (max) {
                case min: h = 0; break;
                case r: h = (g - b) + d * (g < b ? 6: 0); h /= 6 * d; break;
                case g: h = (b - r) + d * 2; h /= 6 * d; break;
                case b: h = (r - g) + d * 4; h /= 6 * d; break;
            }
            return {
                h: h,    s: s,    v: v
            };
        }

        function hsv2rgb(h, s, v) {
            var r, g, b, i, f, p, q, t;

            h = h*360;  s = s*100;    v = v*100;

            // Make sure our arguments stay in-range
            h = Math.max(0, Math.min(360, h));
            s = Math.max(0, Math.min(100, s));
            v = Math.max(0, Math.min(100, v));
            
            h /= 360;   s /= 100;     v /= 100;

            i = Math.floor(h * 6);
            f = h * 6 - i;
            p = v * (1 - s);
            q = v * (1 - f * s);
            t = v * (1 - (1 - f) * s);
            switch (i % 6) {
                case 0: r = v, g = t, b = p; break;
                case 1: r = q, g = v, b = p; break;
                case 2: r = p, g = v, b = t; break;
                case 3: r = p, g = q, b = v; break;
                case 4: r = t, g = p, b = v; break;
                case 5: r = v, g = p, b = q; break;
            }
            return {
                r: Math.round(r * 255),
                g: Math.round(g * 255),
                b: Math.round(b * 255)
            };
        }

        function clear2(){ //전체 지우기
            const outCanvas = document.getElementById('outCanvas');
            const ctx = outCanvas.getContext('2d');
            ctx.clearRect(0, 0, outCanvas.width, outCanvas.height);
        }
        function saveImage() { //저장 함수
            console.log("saveImage()");
            var imageName = "Image";
            console.log(imageName.lenght);
            if (imageName.length == 0) {
                imageName = "image";
            }
            imageName += ".png";
            var savedImage = document.getElementById("saveImage");
            var image = document
                .getElementById("outCanvas")
                .toDataURL("image/png")
                .replace("image/png", "image/octet-stream");
            savedImage.setAttribute("download", imageName);
            savedImage.setAttribute("href", image);
        }

    </script>
    <style>
</style>

    

</body>
</html>